<div class="row" style="height:400px">
  <div id="gia" class="col-md-4">
    <div class="panel panel-default">
      <div class="panel-heading"><h3>GIA</h3></div>
      <div class="panel-body">
        <p>
          <span class="label label-default">Running</span>
          <span class="time">10:02:03</span>
        </p>
        <div id="gia-graph" class="well">
          <svg class="chart" width="100%" height="100%">
          </svg>
        </div>
      </div>
    </div>
  </div>
  <div id="cgia" class="col-md-4">
    <div class="panel panel-default">
      <div class="panel-heading"><h3>CGIA</h3></div>
      <div class="panel-body">
        <p>
          <span class="label label-default">Running</span>
          <span class="time">10:02:03</span>
        </p>
        <div id="cgia-graph" class="well">
          <svg class="chart" width="100%" height="100%">
          </svg>
        </div>
      </div>
    </div>
  </div>
  <div id="pgia" class="col-md-4">
    <div class="panel panel-default">
      <div class="panel-heading"><h3>PGIA</h3></div>
      <div class="panel-body">
        <p>
          <span class="label label-success">Finished</span>
          <span class="time">10:02:03</span></p>
        <div id="pgia-graph" class="well">
          <svg class="chart" width="100%" height="100%">
          </svg>
        </div>
      </div>
    </div>
  </div>
</div>

<script>

  refresh_timer_interval_id = null;

  refresh_panel_time = function(panel, data) {
    var panel_status_text = panel.find("p span.time");

    var duration = null;

    // Calculate the duration to show.
    if (data.finished) {
      // Calculate finished_time - start_time.
      var finished_time = Date.parse(data.finished_time);
      var start_time = Date.parse(data.start_time);

      duration = finished_time - start_time;
    } else {
      // Calculate current time - start_time
      var current_time = Date.now();
      var start_time = Date.parse(data.start_time);

      duration = current_time - start_time;
    }

    var seconds = Math.floor((duration / 1000) % 60);
    var minutes = Math.floor((duration / 1000 / 60) % 60);
    var hours = Math.floor((duration / 1000 / 60 / 60));

    panel_status_text.text(hours + ":" + minutes + ":" + seconds);
  }

  refresh_times = function() {
    var gia_panel = $("#gia");
    refresh_panel_time(gia_panel, gia);

    var cgia_panel = $("#cgia");
    refresh_panel_time(cgia_panel, cgia);

    var pgia_panel = $("#pgia");
    refresh_panel_time(pgia_panel, pgia);
  };

  refresh_panel = function(panel_id, panel, data) {
    var panel_status_label = panel.find("p span.label");

    // Refresh the status label and running times.

    refresh_panel_time(panel, data);

    panel_status_label.removeClass("label-success label-default");

    if (data.finished) {
      panel_status_label.text("Finished");
      panel_status_label.addClass("label-success");
    } else {
      panel_status_label.text("Running");
      panel_status_label.addClass("label-default");
    }

    // Refresh the graph.
    var graph = d3.select("#" + panel_id + " svg");

    var xmin = 0;
    var xmax = model.metric_maximums[model.metrics[0]];
    var ymin = 0;
    var ymax = model.metric_maximums[model.metrics[1]];

    var graph_width = parseInt(graph.style("width"), 10);
    var graph_height = parseInt(graph.style("height"), 10);
    var x_padding = 50;
    var y_padding = 50;

    var xscaler = d3.scale.linear()
                          .domain([xmin, xmax])
                          .range([x_padding, graph_width - x_padding])
                          .nice();
    var yscaler = d3.scale.linear()
                          .domain([ymin, ymax])
                          .range([graph_height - y_padding, y_padding])
                          .nice();

    var x_axis_function = d3.svg.axis()
                                .scale(xscaler)
                                .orient("bottom");
    var y_axis_function = d3.svg.axis()
                                .scale(yscaler)
                                .orient("left");

    // Find the x-axis of the graph.
    var x_axis = graph.select("g.x-axis");
    if (x_axis.empty()) {
      x_axis = graph.append("g")
                    .classed("x-axis", true);
    }

    // Apply the axis function to it.
    x_axis.attr("transform", "translate(0,"+(graph_height - y_padding) + ")")
          .call(x_axis_function);

    // Find the y-axis of the graph.
    var y_axis = graph.select("g.y-axis");
    if (y_axis.empty()) {
      y_axis = graph.append("g")
                    .classed("y-axis", true);
    }

    // Apply the axis function to it.
    y_axis.attr("transform", "translate(" + x_padding + ",0)")
          .call(y_axis_function);

    // Draw the pareto points.
    pareto_points = graph.select("g.pareto-points");
    if (pareto_points.empty()) {
      pareto_points = graph.append("g")
                           .classed("pareto-points", true);
    }

    // Update existing points
    pareto_points = pareto_points.selectAll("circle")
                                 .data(data.pareto_points)
                                 .attr("cx", function(d) {
                                    return xscaler(d[model.metrics[0]]) ;
                                 })
                                 .attr("cy", function(d) {
                                    return yscaler(d[model.metrics[1]]);
                                 })
                                 .attr("r", 4)
                                 .classed("pareto-point", true);

    // Add new points
    pareto_points.enter().append("circle")
                         .attr("cx", function(d) {
                            return xscaler(d[model.metrics[0]]);
                         })
                         .attr("cy", function(d) {
                            return yscaler(d[model.metrics[1]]);
                         })
                         .attr("r", 4)
                         .classed("pareto-point", true);

    // Remove unneeded points.
    pareto_points.exit().remove();
  };

  refresh = function(data) {
    console.log("refreshing");

    // Update the global model information.
    model = {
      model_name: data.model_name,
      total_pareto_points: data.total_pareto_points,
      metrics: data.metrics,
      metric_directions: data.metric_directions,
      metric_maximums: data.metric_maximums
    };

    // Update the GIA section.
    gia = data.gia;
    var gia_panel = $("#gia");

    refresh_panel("gia", gia_panel, gia);

    // Update the CGIA section.
    cgia = data.cgia;
    var cgia_panel = $("#cgia");

    refresh_panel("cgia", cgia_panel, cgia);

    // Update the PGIA section.
    pgia = data.pgia;
    var pgia_panel = $("#pgia");

    refresh_panel("pgia", pgia_panel, pgia);
  };

  $(document).ready(function() {
    socket = new WebSocket("ws://localhost:9393/ws");

    socket.onerror = function(event) {
      console.log("Connection to server failed.");
    };

    socket.onopen = function (event) {
      console.log("Connection to server established.");

      // Send the refresh command to the server to get the
      // entire state of the demo.

      var command = {
        command: "refresh"
      };

      socket.send(JSON.stringify(command));
    };

    socket.onmessage = function(event) {
      console.log("Message received.");
      console.log(event.data);

      var decoded_message = JSON.parse(event.data);
      console.log(decoded_message);
      switch(decoded_message.command) {
        case "refresh":
          console.log("Received refresh data from server.");
          refresh(decoded_message.body);

          if (!refresh_timer_interval_id) {
            refresh_timer_interval_id = window.setInterval(refresh_times, 1000);
          }

          var refresh_command = {
            command: "refresh"
          };

          setTimeout(socket.send.bind(socket, JSON.stringify(refresh_command)), 5000);

          break;
      }
    };
  });
</script>
